--FOREIGN KEY / FLASHBACK - PURGE / VIEW - INLINEVIEW / SEQUENCE

--FOREIGN KEY (참조키) : 부모케이블에 저장된 행의 컬럼값 참조 -> 자식테이블의 컬럼에 비정상적인 값이 저장되는 것을 방지함.
--부모 테이블의 PK 참조하여 자식테이블의 컬럼에 FK 제약조건을 설정함.  ->  테이블의 관계를 구현하기 위한 제약조건 임.

CREATE TABLE SUBJECT1(SNO NUMBER(2) CONSTRAINT SUBJECT1_SNO_PK PRIMARY KEY, SNAME VARCHAR2(20));

INSERT INTO SUBJECT1 VALUES(10,'JAVA');
INSERT INTO SUBJECT1 VALUES(20,'JSP');
INSERT INTO SUBJECT1 VALUES(30,'SPRING');
SELECT * FROM SUBJECT1;
COMMIT;

--TRAINEE1 테이블 생성 : 수강생 번호(숫자, PK)/이름 : 문자 / 과목코드 : 숫자
CREATE TABLE TRAINEE1(TNO NUMBER(4) CONSTRAINT TRAINEE1_TNO_PK PRIMARY KEY, TNAME VARCHAR2(20),SCODE NUMBER(2));
INSERT INTO TRAINEE1 VALUES(1000,'홍길동',10);
INSERT INTO TRAINEE1 VALUES(2000,'임꺽정',20);
INSERT INTO TRAINEE1 VALUES(3000,'전우치',30);
INSERT INTO TRAINEE1 VALUES(4000,'일지매',40);
SELECT * FROM TRAINEE1;
COMMIT;

--TRAINEE1 테이블과 SUBJECT1 테이블에서 모든 수강생의 수강생번호, 수강생이름, 수강과목명 검색
-- 결합조건 : TRAINEE1 테이블의 SCODE = SUBJECT1 테이블의 SNO
-- 같은 컬럼의 조합이므로 -> INNER JOIN ~ ON
SELECT TNO, TNAME, SNAME FROM TRAINEE1 JOIN SUBJECT1 ON SCODE=SNO;
--> 결합조건이 참인 행만 결합하여 검색 => 일지매는 검색되지 않음 (수강과목이 존재하지 않음)
--> 모든 수강생들을 검색하고 싶다면, LEFT OUTER JOIN 수행
SELECT TNO, TNAME, SNAME FROM TRAINEE1 LEFT OUTER JOIN SUBJECT1 ON SCODE=SNO;

--TRAINEE2 테이블 생성 - 수강생번호(숫자형-PK), 이름, 과목코드 - FK)
CREATE TABLE TRAINEE2 (TNO NUMBER(4) CONSTRAINT TRAINEE2_TNO_PK PRIMARY KEY, TNMAE VARCHAR2(20), SCODE NUMBER(2), CONSTRAINT TRAINEE2_SCODE_FK FOREIGN KEY(SCODE)REFERENCES SUBJECT1(SNO));
INSERT INTO TRAINEE2 VALUES(1000,'홍길동',10);
INSERT INTO TRAINEE2 VALUES(2000,'임꺽정',20);
INSERT INTO TRAINEE2 VALUES(3000,'전우치',30);
INSERT INTO TRAINEE2 VALUES(4000,'일지매',40); --FK 제약조건 위배
SELECT * FROM TRAINEE2;
COMMIT;

ALTER TABLE TRAINEE2 RENAME COLUMN TNMAE TO TNAME;
--TRAINEE2 & SUBJECT1 테이블에서 수강생 번호, 이름, 과목명 검색
SELECT TNO,TNAME,SNAME FROM TRAINEE2 JOIN SUBJECT1 ON SCODE=SNO;

-- 수강생번호 1000 -> 40 으로 변경
UPDATE TRAINEE2 SET SCODE=40 WHERE TNO=1000;  --FK 제약조건 위배 
-->SCODE는 SUBJECT1의 SCODE를 참조하는 FOREIGN KEY 이기 때문에 SUBJECT1테이블에 없는 값으로는 바꿀수 없음.

--SUBJECT 테이블에서 과목코드가 10인 과목정보 삭제
--자식테이블에서 참조되는 부모 테이블의 행 삭제 불가능
DELETE FROM SUBJECT1 WHERE SNO=10;  --FK 제약조건 위배


--SUBJECT2 테이블 생성 - 과목코드(숫자형-PRIMARY KEY),과목명(문자형) : 부모 테이블
CREATE TABLE SUBJECT2(SNO NUMBER(2) CONSTRAINT SUBJECT2_SNO_PK PRIMARY KEY,SNAME VARCHAR2(20));

--SUBJECT2 테이블에 행 삽입
INSERT INTO SUBJECT2 VALUES(10,'JAVA');
INSERT INTO SUBJECT2 VALUES(20,'JSP');
INSERT INTO SUBJECT2 VALUES(30,'SPRING');
SELECT * FROM SUBJECT2;
COMMIT;

--TRAINEE3 테이블 생성 - 수강생번호(숫자형-PRIMARY KEY),수강생이름(문자형),수강과목코드(숫자형-FOREIGN KEY) : 자식 테이블
--TRAINEE3 테이블의 수강과목코드(SCODE)에 FOREIGN KEY 제약조건을 설정하여 SUBJECT2 테이블의 과목코드(SNO)를 참조
--FOREIGN KEY 제약조건 설정시 ON DELETE CASCADE 또는 ON DELETE SET NULL 기능 추가
--ON DELETE CASCADE : 부모 테이블의 행을 삭제할 경우 자식 테이블의 참조 컬럼값이 저장된 행도 삭제 처리하는 기능 제공
--ON DELETE SET NULL : 부모 테이블의 행을 삭제할 경우 자식 테이블의 참조 컬럼값을 NULL로 변경하는 기능 제공
CREATE TABLE TRAINEE3(TNO NUMBER(4) CONSTRAINT TRAINEE3_TNO_PK PRIMARY KEY,TNAME VARCHAR2(20),SCODE NUMBER(2)
    ,CONSTRAINT TRAINEE3_SCODE_FK FOREIGN KEY(SCODE) REFERENCES SUBJECT2(SNO) ON DELETE CASCADE);
INSERT INTO TRAINEE3 VALUES(1000,'홍길동',10);
INSERT INTO TRAINEE3 VALUES(2000,'임꺽정',20);
INSERT INTO TRAINEE3 VALUES(3000,'전우치',30);
SELECT * FROM TRAINEE3;
COMMIT;

--subject2 테이블에서 과목코드가 10인 과목정보 삭제
DELETE FROM SUBJECT2 WHERE SNO=10;  -- ON DELETE CASCADE는 해당 테이블을 참조하는 테이블의 정보까지 함께 삭제함으로써 삭제명령 수행시 문제발생X
--SUBJECT2 테이블(부모 TABLE)의 과목코드를 참조하는 TRAINEE3 테이블의 수강생 정보 삭제
SELECT * FROM SUBJECT2;
SELECT * FROM TRAINEE3;

-- 서브쿼리를 사용하여 테이블 생성 가능 - 기존 테이블을 이용하여 새로운 테이블 생성 -> 행 복사 가능 // 제약조건 복사 불가
-- 서브쿼리의 검색결과 => 타겟테이블 생성 // 검색된 행은 타겟테이블의 행으로 삽입처리
-- 타겟테이블의 컬럼명 변경가능 -> BUT 자료형 & 크기 변경 불가
-- 원본테이블의 제약조건은 복사되지 않음

-- EMP 테이블에 저장된 모든 사원의 사원 정보를 검색하여 EMP_COPY 테이블 생성 - 검색행 삽입처리
CREATE TABLE EMP_COPY AS SELECT * FROM EMP;

-- EMP 테이블과 EMP_COPY 테이블의 구조 비교 -> 원본테이블 속서 = 타겟테이블 속성
DESC EMP;
DESC EMP_COPY;

-- 원본, 타겟 테이블의 제약조건 비교 (제약조건 복사X)
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE FROM USER_CONSTRAINTS WHERE TABLE_NAME='EMP';
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE FROM USER_CONSTRAINTS WHERE TABLE_NAME='EMP_COPY';  --비어있음. 제약조건은 COPY 되지 않음.

-- 원본, 카피 행비교 (행 복사O)
SELECT * FROM EMP;
SELECT * FROM EMP_COPY;

-- EMP 테이블에 저장된 모든 사원의 사원번호, 사원이름, 급여를 검색하여 EMP_COPY2 테이블을 생성하고 검색행을 삽입처리 함.
CREATE TABLE EMP_COPY2 AS SELECT EMPNO,ENAME,SAL FROM EMP;
DESC EMP_COPY2;  --3개 컬럼만 복사 됨
SELECT * FROM EMP_COPY2;

--EMP 테이블에서 급여가 2000이상인 사원의 사원번호, 이름, 급여 검색 -> EMP_COPY3 생성
CREATE TABLE EMP_COPY3 AS SELECT EMPNO,ENAME,SAL FROM EMP WHERE SAL>=2000;
DESC EMP_COPY3;  
SELECT * FROM EMP_COPY3;

-- EMP_COPY4 테이블을 EMP_COPY3과 같은 구조로 생성하고 컬럼명 변경하기. -> NO, NAME, PAY
CREATE TABLE EMP_COPY4(NO,NAME,PAY) AS SELECT EMPNO,ENAME,SAL FROM EMP WHERE SAL>=2000;
DESC EMP_COPY4;  
SELECT * FROM EMP_COPY4;

--원본의 행이 타겟의 행에 삽입처리되지 않도록
CREATE TABLE EMP_COPY5 AS SELECT * FROM EMP WHERE 0=1; --조건식이 무조건 거짓 -> 행 미검색 -> 구조만 복사됨 
DESC EMP_COPY5;  
SELECT * FROM EMP_COPY5;


--테이블 삭제 = DROP (AUTO COMMIT 되므로 복구 불가)

--테이블목록 확인 - USER_TABLES 딕셔너리 이용
SELECT TABLE_NAME FROM TABS WHERE TABLE_NAME LIKE 'USER%';
SELECT * FROM TAB WHERE TNAME LIKE 'USER%';

DROP TABLE USER1;
SELECT TABLE_NAME FROM TABS WHERE TABLE_NAME LIKE 'USER%';

--USER_TABLES 딕셔너리 대신 TAB 뷰를 이용하여 테이블 목록 검색 가능
--오라클의 경우 테이블 삭제시 바로 삭제하는것이 아니라 휴지통이라는 삭제 테이블로 이동됨(논리적 삭제) => 즉, ORACLE의 경우에는 DROP 한 테이블도 복구 가능
-- BIN~~~테이블이 바로 삭제된 테이블
SHOW RECYCLEBIN;
--FLASHBACK ~ TO BEFORE DROP명령어 통해 삭제 테이블 복구
FLASHBACK TABLE USER1 TO BEFORE DROP;
SELECT TABLE_NAME FROM USER_TABLES WHERE TABLE_NAME LIKE 'USER%';
SELECT * FROM USER1;

--TABLE USER2 삭제 
--오라클 휴지통에는 테이블 뿐만 아니라 인덱스 객체도 같이 존재함
DROP TABLE USER2;
SHOW RECYCLEBIN;

--USER2 테이블 복구 -> 종속관계의 인덱스 객체도 복구
FLASHBACK TABLE USER2 TO BEFORE DROP;
SHOW RECYCLEBIN;

--오라클 휴지통의 테이블 삭제 - 테이블에 종속된 인덱스 객체가 같이 삭제 처리
--형식) PURGE TABLE 테이블명 
DROP TABLE USER4;
PURGE TABLE USER4;--물리적 삭제
SHOW RECYCLEBIN;

--MGR1 테이블 삭제
SELECT TABLE_NAME FROM USER_TABLES WHERE TABLE_NAME LIKE 'MGR%';
DROP TABLE MGR1;
SHOW RECYCLEBIN;
PURGE RECYCLEBIN; --휴지통 전체 삭제

SELECT TABLE_NAME FROM TABS WHERE TABLE_NAME='MGR%';

--테이블 초기화 : 테이블을 생성 직후의 상태로 초기화 처리하는 명령 - 테이블에 저장된 모든 행 삭제 처리
-- TRUNCATE TABLE-> 테이블 삭제나 데이터 삭제가 아닌 ㄹㅇ 처음 상태로 롤백하는것. 
DELETE FROM BONUS; --실제 테이블의 행 삭제X (트렌잭션에 명령을 저장한 것.)
SELECT* FROM BONUS;
ROLLBACK;

TRUNCATE TABLE BONUS;  -- DDL이므로 AUTO COMMIT됨 -> 복구 불가 (휴지통에도 저장X)
SELECT * FROM BONUS;

SHOW RECYCLEBIN;

--테이블 이름 변경 : RENAME
RENAME BONUS TO COMM;
SELECT TABLE_NAME FROM USER_TABLES WHERE TABLE_NAME IN ('BONUS','COMM'); --COMM만 존재함.

--테이블의 속성 및 제약조건 변경
--형식)ALTER TALBE 테이브명 변경옵션(속성OR제약조건)
DROP TABLE USER1;
CREATE TABLE USER1(NO NUMBER(4), NAME VARCHAR2(20), PHONE VARCHAR2(15));
DESC USER1;

INSERT INTO USER1 VALUES(1000,'홍길동','010-1234-5678');
SELECT * FROM USER1;
COMMIT;

--속성 추가
ALTER TABLE USER1 ADD (ADDRESS VARCHAR2(100));
DESC USER1;
SELECT * FROM USER1;
UPDATE USER1 SET ADDRESS='서울시 강남구' WHERE NO=1000;
--> BUT 저장행이 많은 테이블에 컬럼 추가시, 해당 컬럼의 자료를 하나하나 입력해야 하므로 잘 쓰지X
--> 차라리 새 테이블을 만들어 MERGE? JOIN? 시키는 것이 나음.
COMMIT;

TRUNCATE TABLE USER1;
--자료형 / 크기 변경 : MODIFY : 기본값 및 컬럼 수준의 제약조건 설정 가능
ALTER TABLE USER1 MODIFY (NO VARCHAR2(4));

DESC USER1;
INSERT INTO USER1 VALUES('1000','홍길동','010-1234-5678','서울시 강남구');
COMMIT;

SELECT* FROM USER1;
--NO의 속성을 문자형 -> 숫자형으로 변경 : 불가능! (이미 저장돼있는 컬럼값이 있는 경우 컬럼값의 크기보다 작은 컬럼의 크기로는 변경이 불가함.)
ALTER TABLE USER1 MODIFY(NO NUMBER(5));  -- 에러 발생

--테이블 속성의 컬럼명 변경 (저장행 유무 상관X)
DESC USER1;
ALTER TABLE USER1 RENAME COLUMN ADDRESS TO ADDR;

--속성 삭제 : 테이블 속성에 저장된 컬럼값 삭제
ALTER TABLE USER1 DROP COLUMN PHONE;
DESC USER1;

--제약조건 추가 : NAME 컬럼에 NOT NULL 제약조건 추가
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE FROM USER_CONSTRAINTS WHERE TABLE_NAME ='USER1';
ALTER TABLE USER1 MODIFY(NAME VARCHAR2(10) CONSTRAINT USER1_NAME_NN NOT NULL);
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE FROM USER_CONSTRAINTS WHERE TABLE_NAME='USER1';

--테이블 수준 제약조건 : ADD 옵션 사용하여 추가
--EX) NO 컬럼에 PK 제약조건 추가
ALTER TABLE USER1 ADD CONSTRAINT USER1_NO_PK PRIMARY KEY(NO);
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE FROM USER_CONSTRAINTS WHERE TABLE_NAME='USER1';

--제약조건 삭제
ALTER TABLE USER1 DROP CONSTRAINT USER1_NAME_NN;
ALTER TABLE USER1 DROP PRIMARY KEY;

--뷰(VIEW) : 테이블을 기반으로 만들어지는 가상의 테이블 - 단순뷰와 복합뷰로 구분
--뷰는 테이블의 행검색 또는 테이블의 권한 설정을 간편하게 제공하기 위해 생성
--단순뷰 : 하나의 테이블을 기반으로 생성되는 뷰 - 뷰를 이용한 테이블의 검색뿐만 아니라 테이블의 행 삽입,삭제,변경 가능
--단순뷰 생성시 그룹함수 또는 DISTINCT 키워드를 사용한 경우 검색만 가능
--복합뷰 : 여러개의 테이블을 기반으로 생성된 뷰 - 테이블의 행을 결합하여 생성된 뷰 - 검색만 가능

--뷰 생성 -> 서브쿼리 이용 (상단의 서브쿼리를 이용해 CREATE  TABLE 한것과 유사함)
-- 1. CREATE OR REPLACE : 동일한 이름의 뷰가 있는 경우 기존 뷰를 삭제하고 새로운 뷰가 생성됨
-- 2. FORCE : 서브쿼리의 검색결과가 없어도 강제로 뷰를 생성하기 위한 기능을 제공함
-- 3. WITH CHECK OPTION : 뷰를 생성한 서브쿼리의 조건식에서 사용된 컬럼값을 변경하지 못하도록 설정하는 기능 제공
-- 4. WITH READ ONLY : 검색만 가능하도록 설정

-- EMP_COPY 테이블로에서 부서번호가 30인 사원번호, 이름, 부서번호 검색 -> EMP_VIEW30 생성
SELECT * FROM EMP_COPY;
CREATE VIEW EMP_VIEW30 AS SELECT EMPNO,ENAME,DEPTNO FROM EMP_COPY WHERE DEPTNO=30; -- 권한 불충분 ERROR (뷰생성에 대한 권리는 관리자에게만 있음 -> 보통 일반사용자는 사용 X)
--> 권한 부여해줌 : GRANT CREATE VIEW TO SCOTT; -> 관리자(SYS)계정으로 접속하여 권한 부여 
--GRANT CREATE VIEW TO SCOTT;
CREATE VIEW EMP_VIEW30 AS SELECT EMPNO,ENAME,DEPTNO FROM EMP_COPY WHERE DEPTNO=30; -- 권한 불충분 ERROR (뷰생성에 대한 권리는 관리자에게만 있음 -> 보통 일반사용자는 사용 X)

--단순뷰는 삽입, 삭제, 변경 가능
INSERT INTO EMP_VIEW30 VALUES(1111,'홍길동',30);
SELECT* FROM EMP_VIEW30;
SELECT* FROM EMP_COPY;

--EMP_VIEW10 생성
CREATE VIEW EMP_VIEW10 AS SELECT EMPNO,ENAME,DNAME FROM EMP JOIN DEPT ON EMP.DEPTNO=DEPT.DEPTNO; -- 복합뷰
SELECT* FROM emp_view10;

--동일 이름으로 생성시 에러 발생
CREATE VIEW EMP_VIEW10 AS SELECT EMPNO,ENAME,SAL,DNAME FROM EMP JOIN DEPT ON EMP.DEPTNO=DEPT.DEPTNO; -- 복합뷰
--CREATE OR REPLACE 명령어 사용 : 기존 뷰 삭제 -> 새로운 VIEW 생성
CREATE OR REPLACE VIEW EMP_VIEW10 AS SELECT EMPNO,ENAME,DNAME FROM EMP JOIN DEPT ON EMP.DEPTNO=DEPT.DEPTNO; -- 복합뷰
SELECT VIEW_NAME, TEXT FROM USER_VIEWS;

--뷰를 생성하지 않고 SELECT 명령의 서브쿼리를 사용하여 인라인 뷰를 생성하여 사용
SELECT * FROM (SELECT EMPNO,ENAME, SAL, DNAME FROM EMP JOIN DEPT ON EMP.DEPTNO=DEPT.DEPTNO);
--> 인라인뷰의경우 CREATE VIEW 권한은 필요 X

-- 뷰 삭제 : DROP
SELECT VIEW_NAME,TEXT FROM USER_VIEWS;
DROP VIEW EMP_VIEW30;
SELECT VIEW_NAME,TEXT FROM USER_VIEWS;

--시퀀스(SEQUENCE) : 숫자값(정수값)을 저장 -> 자동 증가되는 값을 제공하는 객체 - 테이블 컬럼에 고유값 전달
--> 1. 생성 : CREATE SEQUENCE
--> 2. START WITH 초기값 : 시퀀스에 저장된 초기값 설정 (생략시 NULL)
--> 3. INCREMENT BY 증가값 : 자동 증가되는 숫자값 설정 ->  생략 : 1
--> 4. MAXVALUE : 저장 가능 최댓값 - 생략 : 오라클에서 숫자값으로 표현 가능한 최댓값
--> 5. MINVALUE : 저장 가능 최솟값 - 생략 : 1
--> 6. CYCLE : 시퀀스에 저장된 값이 최댓값을 초과할 경우 최소값부터 다시 제공되도록 반복기능 제공
--> 7. CACHE 갯수 : 임의의 저장공간에 자동 증가값을 미리 생성하여 재공할 수 있는 갯수 설정 - 생략 : 20
SELECT* FROM TAB;
DROP TABLE USER2;
CREATE TABLE USER2 (NO NUMBER(2) CONSTRAINT USER_NO_PK PRIMARY KEY, NAME VARCHAR2(20),BIRTHDAT DATE);
DESC USER2;




--시퀀스 생성
CREATE SEQUENCE USER2_SEQ;
--확인
SELECT SEQUENCE_NAME,MAX_VALUE,MIN_VALUE,INCREMENT_BY FROM USER_SEQUENCES;

--시퀀스에 저장된 숫자값 확인
--형식) 시퀀스명.CURRVAL : 현재값 // NEXTVAL : 1증가
SELECT USER2_SEQ.CURRVAL FROM DUAL; -- 시퀀스에 NULL값이 저장돼있는 경우 ERROR

--시퀸스에 저장된 숫자값를 이용하여 증가된 값을 제공하는 방법 - 증가된 값 제공후 시퀸스는 증가된 값으로 자동 변경
--시퀸스에 NULL이 저장되어 있는 경우 시퀸스의 최소값을 제공한 후 시퀸스의 저장값 변경 처리

SELECT * FROM USER2;
SELECT USER2_SEQ.NEXTVAL FROM DUAL;
SELECT USER2_SEQ.CURRVAL FROM DUAL;
SELECT USER2_SEQ.NEXTVAL FROM DUAL;
SELECT USER2_SEQ.CURRVAL FROM DUAL;

SHOW RECYCLEBIN;
DROP TABLE USER3;
DROP TABLE USER4;
PURGE RECYCLEBIN;
SELECT TABLE_NAME FROM USER_TABLES WHERE TABLE_NAME LIKE 'USER%';

INSERT INTO USER2 VALUES(USER2_SEQ.NEXTVAL,'홍길동','00/01/01');
INSERT INTO USER2 VALUES(USER2_SEQ.NEXTVAL,'임꺽정','00/12/31');
INSERT INTO USER2 VALUES(USER2_SEQ.NEXTVAL,'전우치',SYSDATE);

SELECT* FROM USER2;
COMMIT;

--시퀀스 변경
SELECT* FROM USER2;
SELECT SEQUENCE_NAME,MAX_VALUE,MIN_VALUE,INCREMENT_BY FROM USER_SEQUENCES;
ALTER SEQUENCE USER2_SEQ MAXVALUE 99 INCREMENT BY 5;
SELECT SEQUENCE_NAME,MAX_VALUE,MIN_VALUE,INCREMENT_BY FROM USER_SEQUENCES;

SELECT USER2_SEQ.CURRVAL FROM DUAL; -- 결과 5
INSERT INTO USER2 VALUES(USER2_SEQ.NEXTVAL,'일지매','03/09/09');
--INCREMENT_BY로 증가값을 5로 바꾸었으므로 NO = 10 / SEQ.CURRVAL = 10
SELECT * FROM USER2;
SELECT USER2_SEQ.CURRVAL FROM DUAL;--검색결과 : 10
COMMIT;
